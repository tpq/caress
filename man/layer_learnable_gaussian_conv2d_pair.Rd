% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/2-layers-learnable-gaussian.R
\name{layer_learnable_gaussian_conv2d_pair}
\alias{layer_learnable_gaussian_conv2d_pair}
\title{Initialize Learnable Layer}
\usage{
layer_learnable_gaussian_conv2d_pair(
  input,
  kernel_size,
  receptor_row = 1,
  target_row = receptor_row,
  target_mirror = FALSE,
  name = NULL
)
}
\arguments{
\item{input}{The incoming layer.}

\item{kernel_size}{Exactly 2 integers. The dimensionality
of the learned filter. The second number refers to the total
number of nodes in the Gaussian kernel.}

\item{receptor_row}{The row in the filter kernel that should
follow a Gaussian distribution.}

\item{target_row}{The row in the filter kernel that should
have 1 in the first (or last) column.}

\item{target_mirror}{Toggles whether the \code{target_row}
should have 1 in the first or last column. When \code{target_mirror = FALSE},
the first column is used.}

\item{name}{A string. The prefix label for all layers.}
}
\value{
A layer of learnable weights.
}
\description{
This function creates a layer as a matrix, such that the
 activity of one row is spatially organized to follow a Gaussian
 distribution (based on a learnable mu and sigma).
}
\details{
Example output:
[1,] 1.000000 0.0000000 0.00000000
[2,] 0.072769 0.2522599 0.00235219
[3,] 0.000000 0.0000000 0.00000000
[4,] 0.000000 0.0000000 0.00000000
}
\examples{
library(keras)
library(caress)
x <- as.matrix(iris[,1:4])
y <- to_categorical(as.numeric(iris[,5])-1)
k_clear_session()
input <- from_input(x)
reshape <- input \%>\%
  layer_dense(20, kernel_constraint = constraint_all_ones, use_bias = FALSE) \%>\%
  layer_reshape(c(4,5,1))
weight <- input \%>\%
  layer_learnable_gaussian_conv2d_pair(c(4, 5), target_row = 2, receptor_row = 4)
target <- layer_kernel_conv2d(reshape, weight) \%>\%
  layer_flatten() \%>\%
  to_output(y)
m <- prepare(input, target)
build(m, x, y, batch_size = 4, epochs = 100)
get_layer_output(m, x, "input_gaussian_conv2d_pair")
}
